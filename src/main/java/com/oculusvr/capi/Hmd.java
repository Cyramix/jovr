package com.oculusvr.capi;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.util.Arrays;
import java.util.List;

import javax.annotation.Nonnull;

import com.google.common.base.Preconditions;
import com.oculusvr.capi.OvrLibrary.ovrHmdStruct;
import com.sun.jna.Pointer;
import com.sun.jna.Structure;
/**
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class Hmd extends Structure {
  public ovrHmdStruct Handle;
  public int Type;
  public Pointer ProductName;
  public Pointer Manufacturer;
  public short VendorId;
  public short ProductId;
  public byte[] SerialNumber = new byte[24];
  public short FirmwareMajor;
  public short FirmwareMinor;
  /** < Horizontal field-of-view */
  public float CameraFrustumHFovInRadians;
  /** < Vertical field-of-view */
  public float CameraFrustumVFovInRadians;
  /** < Near clip distance */
  public float CameraFrustumNearZInMeters;
  /** < Far clip distance */
  public float CameraFrustumFarZInMeters;
  public int HmdCaps;
  public int TrackingCaps;
  public int DistortionCaps;
  public FovPort[] DefaultEyeFov = new FovPort[com.oculusvr.capi.OvrLibrary.ovrEyeType.ovrEye_Count];
  public FovPort[] MaxEyeFov = new FovPort[com.oculusvr.capi.OvrLibrary.ovrEyeType.ovrEye_Count];
  public int[] EyeRenderOrder = new int[com.oculusvr.capi.OvrLibrary.ovrEyeType.ovrEye_Count];
  public OvrSizei Resolution;
  public OvrVector2i WindowsPos;
  public Pointer DisplayDeviceName;
  public int DisplayId;
  public Hmd() {
         super();
  }
  @Override
  protected List<? > getFieldOrder() {
         return Arrays.asList("Handle", "Type", "ProductName", "Manufacturer", "VendorId", "ProductId", "SerialNumber", "FirmwareMajor", "FirmwareMinor", "CameraFrustumHFovInRadians", "CameraFrustumVFovInRadians", "CameraFrustumNearZInMeters", "CameraFrustumFarZInMeters", "HmdCaps", "TrackingCaps", "DistortionCaps", "DefaultEyeFov", "MaxEyeFov", "EyeRenderOrder", "Resolution", "WindowsPos", "DisplayDeviceName", "DisplayId");
  }
  public Hmd(Pointer peer) {
         super(peer);
  }
  
  @Nonnull 
  static private FovPort.ByValue byValue(@Nonnull FovPort fov) {
    if (fov instanceof FovPort.ByValue) {
      return (FovPort.ByValue) fov;
    }
    return new FovPort.ByValue(fov);
  }

  @Nonnull 
  static private Posef.ByValue byValue(@Nonnull Posef pose) {
    if (pose instanceof Posef.ByValue) {
      return (Posef.ByValue) pose;
    }
    return new Posef.ByValue(pose);
  }

  @Nonnull 
  static private OvrMatrix4f.ByValue byValue(@Nonnull OvrMatrix4f m) {
    if (m instanceof OvrMatrix4f.ByValue) {
      return (OvrMatrix4f.ByValue) m;
    }
    return new OvrMatrix4f.ByValue(m);
  }

  @Nonnull 
  static private OvrVector2f.ByValue byValue(@Nonnull OvrVector2f v) {
    if (v instanceof OvrVector2f.ByValue) {
      return (OvrVector2f.ByValue) v;
    }
    return new OvrVector2f.ByValue(v);
  }

  @Nonnull 
  static private OvrSizei.ByValue byValue(@Nonnull OvrSizei v) {
    if (v instanceof OvrSizei.ByValue) {
      return (OvrSizei.ByValue) v;
    }
    return new OvrSizei.ByValue(v);
  }

  @Nonnull 
  static private OvrRecti.ByValue byValue(@Nonnull OvrRecti v) {
    if (v instanceof OvrRecti.ByValue) {
      return (OvrRecti.ByValue) v;
    }
    return new OvrRecti.ByValue(v);
  }
  
  public static void initialize() {
    InitParams init = new InitParams();
    init.Flags = OvrLibrary.ovrInitFlags.ovrInit_Debug;
    init.LogCallback = new OvrLibrary.ovrLogCallback() {
      @Override
      public void apply(int level, String message) {
        System.out.println(message);
      }
    };
    init.ConnectionTimeoutMS = 0;
    init.RequestedMinorVersion = 0;
    if (0 == OvrLibrary.INSTANCE.ovr_Initialize(init)) {
      throw new IllegalStateException("Unable to initialize Oculus SDK");
    }
  }

  public static void shutdown() {
    OvrLibrary.INSTANCE.ovr_Shutdown();
  }

  public static Hmd create(int index) {
    return OvrLibrary.INSTANCE.ovrHmd_Create(index);
  }

  @Nonnull 
  public static Hmd createDebug(int type) {
    return OvrLibrary.INSTANCE.ovrHmd_CreateDebug(type);
  }

  public void destroy() {
    OvrLibrary.INSTANCE.ovrHmd_Destroy(this);
  }

  public String getLastError() {
    return OvrLibrary.INSTANCE.ovrHmd_GetLastError(this);
  }

  public int getEnabledCaps() {
    return OvrLibrary.INSTANCE.ovrHmd_GetEnabledCaps(this);
  }

  public void setEnabledCaps(int hmdCaps) {
    OvrLibrary.INSTANCE.ovrHmd_SetEnabledCaps(this, hmdCaps);
  }

  public byte configureTracking(int supportedSensorCaps, int requiredSensorCaps) {
    return OvrLibrary.INSTANCE.ovrHmd_ConfigureTracking(this, supportedSensorCaps, requiredSensorCaps);
  }

  public void recenterPose() {
    OvrLibrary.INSTANCE.ovrHmd_RecenterPose(this);
  }

  public TrackingState getSensorState(double absTime) {
    return OvrLibrary.INSTANCE.ovrHmd_GetTrackingState(this, absTime);
  }

  public OvrSizei getFovTextureSize(int eye, FovPort fov, float pixelsPerDisplayPixel) {
    return OvrLibrary.INSTANCE.ovrHmd_GetFovTextureSize(this, eye, byValue(fov), pixelsPerDisplayPixel);
  }
  
  private static <T extends Structure> void checkContiguous(T[] ts) {
    Pointer first = ts[0].getPointer();
    int size = ts[0].size();
    Pointer secondCalc = first.getPointer(size);
    Pointer secondActual = ts[1].getPointer().getPointer(0);
    Preconditions.checkArgument(secondCalc.equals(secondActual), 
        "array must be contiguous in memory.");
  }

  public EyeRenderDesc[] configureRendering(RenderAPIConfig apiConfig, int distortionCaps, FovPort eyeFovIn[]) {
    checkContiguous(eyeFovIn);
    EyeRenderDesc eyeRenderDescs[] = (EyeRenderDesc[]) new EyeRenderDesc().toArray(2);
    if (0 == OvrLibrary.INSTANCE.ovrHmd_ConfigureRendering(this, apiConfig, distortionCaps, eyeFovIn, eyeRenderDescs)) {
      throw new IllegalStateException("Unable to configure rendering");
    }
    return eyeRenderDescs;
  }

  public FrameTiming beginFrame(int frameIndex) {
    return OvrLibrary.INSTANCE.ovrHmd_BeginFrame(this, frameIndex);
  }

  public void endFrame(Posef renderPose[], GLTexture eyeTexture[]) {
    OvrLibrary.INSTANCE.ovrHmd_EndFrame(this, renderPose, eyeTexture);
  }

  @Nonnull
  public EyeRenderDesc getRenderDesc(int eyeType, @Nonnull FovPort fov) {
    Preconditions.checkNotNull(fov);
    return OvrLibrary.INSTANCE.ovrHmd_GetRenderDesc(this, eyeType, byValue(fov));
  }

  @Nonnull
  public DistortionMesh createDistortionMesh(int eyeType, @Nonnull FovPort fov, int distortionCaps) {
    Preconditions.checkNotNull(fov);
    DistortionMesh meshData = new DistortionMesh();
    if (0 == OvrLibrary.INSTANCE.ovrHmd_CreateDistortionMesh(this, eyeType, byValue(fov), distortionCaps, meshData)) {
      throw new IllegalStateException("Unable to create distortion mesh");
    }
    return meshData;
  }


  public static void destroyDistortionMesh(DistortionMesh meshData) {
    OvrLibrary.INSTANCE.ovrHmd_DestroyDistortionMesh(meshData);
  }

  public static OvrVector2f[] getRenderScaleAndOffset(FovPort fov, OvrSizei textureSize,
      OvrRecti renderViewport) {
    OvrVector2f results[] = (OvrVector2f[]) new OvrVector2f().toArray(2);
    OvrLibrary.INSTANCE.ovrHmd_GetRenderScaleAndOffset(
        byValue(fov), 
        byValue(textureSize), 
        byValue(renderViewport), 
        results);
    return results;
  }

  
  @Nonnull
  public FrameTiming getFrameTiming(int frameIndex) {
    return OvrLibrary.INSTANCE.ovrHmd_GetFrameTiming(this, frameIndex);
  }

  @Nonnull
  public FrameTiming beginFrameTiming(int frameIndex) {
    return OvrLibrary.INSTANCE.ovrHmd_BeginFrameTiming(this, frameIndex);
  }

  public void endFrameTiming() {
    OvrLibrary.INSTANCE.ovrHmd_EndFrameTiming(this);
  }

  public void resetFrameTiming(int frameIndex) {
    OvrLibrary.INSTANCE.ovrHmd_ResetFrameTiming(this, frameIndex);
  }

  @Nonnull
  @Deprecated
  public Posef getEyePose(int eye) {
    return OvrLibrary.INSTANCE.ovrHmd_GetHmdPosePerEye(this, eye);
  }

  public Posef[] getEyePoses(int frameIndex, OvrVector3f hmdToEyeViewOffsets[]) {
    //checkContiguous(hmdToEyeViewOffsets);
    Posef results[] = (Posef[]) new Posef().toArray(2);
    OvrLibrary.INSTANCE.ovrHmd_GetEyePoses(this, frameIndex, hmdToEyeViewOffsets, results, null);
    return results;
  }

  public void getEyeTimewarpMatrices(int eye, Posef renderPose, OvrMatrix4f twmOut[]) {
    OvrLibrary.INSTANCE.ovrHmd_GetEyeTimewarpMatrices(this, eye, byValue(renderPose), twmOut);
  }

  public byte processLatencyTest(ByteBuffer rgbColorOut) {
    return OvrLibrary.INSTANCE.ovrHmd_ProcessLatencyTest(this, rgbColorOut);
  }

  public Pointer getLatencyTestResult() {
    return OvrLibrary.INSTANCE.ovrHmd_GetLatencyTestResult(this);
  }

  public float getFloat(@Nonnull String propertyName, float defaultVal) {
    return OvrLibrary.INSTANCE.ovrHmd_GetFloat(this, propertyName, defaultVal);
  }

  public byte setFloat(@Nonnull String propertyName, float value) {
    return OvrLibrary.INSTANCE.ovrHmd_SetFloat(this, propertyName, value);
  }

  public float[] getFloatArray(@Nonnull String propertyName, int arraySize) {
    FloatBuffer buffer = FloatBuffer.allocate(arraySize);
    int result = OvrLibrary.INSTANCE.ovrHmd_GetFloatArray(this, propertyName, buffer, arraySize);
    if (0 == result) {
      return null;
    }
    return buffer.array();
  }

  public byte setFloatArray(@Nonnull String propertyName, @Nonnull float[] values) {
    return setFloatArray(propertyName, FloatBuffer.wrap(values), values.length);
  }

  public int getFloatArray(@Nonnull String propertyName, @Nonnull FloatBuffer values, int arraySize) {
    return OvrLibrary.INSTANCE.ovrHmd_GetFloatArray(this, propertyName, values, arraySize);
  }

  public byte setFloatArray(@Nonnull String propertyName, @Nonnull FloatBuffer values, int arraySize) {
    return OvrLibrary.INSTANCE.ovrHmd_SetFloatArray(this, propertyName, values, arraySize);
  }

  public String getString(@Nonnull String propertyName, String defaultVal) {
    return OvrLibrary.INSTANCE.ovrHmd_GetString(this, propertyName, defaultVal);
  }

  public static OvrMatrix4f getPerspectiveProjection(@Nonnull FovPort fov, float znear, float zfar, boolean rightHanded) {
    Preconditions.checkArgument(znear < zfar, "znear must be less than zfar");
    return OvrLibrary.INSTANCE.ovrMatrix4f_Projection(byValue(fov), znear, zfar, (byte) (rightHanded ? 1 : 0));
  }

  public static OvrMatrix4f getOrthographicProjection(@Nonnull OvrMatrix4f projection, @Nonnull OvrVector2f orthoScale,
      float orthoDistance, float eyeViewAdjustX) {
    return OvrLibrary.INSTANCE.ovrMatrix4f_OrthoSubProjection(byValue(projection), byValue(orthoScale), orthoDistance,
        eyeViewAdjustX);
  }

  public static double getTimeInSeconds() {
    return OvrLibrary.INSTANCE.ovr_GetTimeInSeconds();
  }

  public static void waitTillTime(double absTime) {
    OvrLibrary.INSTANCE.ovr_WaitTillTime(absTime);
  }

  public HSWDisplayState getHSWDisplayState() {
    HSWDisplayState hasWarningState = new HSWDisplayState();
    OvrLibrary.INSTANCE.ovrHmd_GetHSWDisplayState(this, hasWarningState);
    return hasWarningState;
  }

  public boolean dismissHSWDisplay() {
    return 0 != OvrLibrary.INSTANCE.ovrHmd_DismissHSWDisplay(this);
  }
  
//  public void enableHswDisplay(boolean enable) {
//    OvrLibrary.INSTANCE.ovrhmd_EnableHSWDisplaySDKRender(this, (byte)(enable ? 1 : 0));
//  }

}
